<a href="#1">🐣 분할과 정복 패턴</a> <br/>

<br/>
<br/>

# 🐣 분할과 정복 패턴  <span id="1">
- 코드를 다루지는 않을 것
- 정렬, 이진 탐색 등 각 파트에서 다시 살펴볼 것임

## 분할 정복 개념
주로 배열이나 문자열 같은 큰 규모의 데이터 셋을 처리. 연결 리스트, 트리 등.

배열을 하나 만들어 보겠음. 값을 찾기 위해 배열의 왼쪽에서 시작하여 오른쪽 끝까지 이동하는 것보다는 배열을 작은 조각으로 세분하여 각 조각들을 어디로 이동시킬지 결정하는 작업부터 시작. 즉, 큰 데이터 덩어리를 작은 조각으로 나누는 것
```
search([1,2,3,4,5,6],4) // 3
search([1,2,3,4,5,6],6) // 5
search([1,2,3,4,5,6],11) // -1
```
- 사실상 이진 탐색이라 불리는 이 배열은 정렬된 숫자를 지닌 배열을 취함.
- 배열은 정렬된 상태여야 함. (1,2,3,4,5,6)이런 상태.
- 입력된 search라는 함수는 값을 취하고 해당 값이 있는 위치(index)를 반환.
- 따라서 4를 전달하면 3이 반환(4의 값은 index 3에 있음). 위치의 순서는 0, 1, 2, 3이니 위치가 4값, index는 3.
- 6를 전달하면 5의 위치가 반환. 11을 전달하면, -1이 반환(11은 여기에 없음)
- 배열 전체에 루프 진행 O(n)

<br/>

- 선형 탐색
- 시간 복잡도 : O(n)
```
function search(arr, val){
  for(let i = 0; i < arr.length; i++){
    if(arr[i] === val){
      return i;
    }
  }
  return -1;
}
```

<br/>

- 이진 탐색
- 분할 정복 알고리즘
- 시간 복잡도 : log(n)
```
function search(array, val) {
  let min = 0;
  let max = array.length - 1;

  while (min <= max) {
    let middle = Math.floor((min + max) / 2);
    let currentElement = array[middle];

    if (array[middle] < val) {
      min = middle + 1;
    } else if (array[middle] > val) {
      max = middle - 1;
    } else {
      return middle;
    }
  }
  return -1;
}
```

[1, 2, 3, 5, 6, 8, 9, 12, 15, 16, 29] 찾으려는 경우
- 선형 탐색의 경우 15를 찾을 때까지 루프 진행
- 이진 탐색의 경우 정렬되어 있으니 중간 지점 선택
- 대강 8을 중간으로 잡았다면, 찾는 값이 8보다 큰지 작은지 확인 (정렬되어 있기 때문에 가능)
- 15는 8보다 크기 때문에 앞쪽의 값은 다 무시하고, 8 이후의 값들에서 찾음
- 9~29 사이에서 또 중간 지점 선택. 15 나옴. 끝
- 큰 배열의 경우(백만개..) 루프 끝까지 반복하면 비효율, 하지만 이진탐색의 경우 효율적
