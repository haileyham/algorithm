# <a href="#1">🐣 삽입 정렬</a> <br/>
# <a href="#2">🐣 삽입 정렬 구현</a> <br/>
# <a href="#3">🐣 삽입 정렬 : 빅오</a> <br/>

<br/>
<br/>

# 🐣   삽입 정렬<span id="1">
## 작동 방식
- 삽입 정렬은 배열의 과반을 점차적으로 만들어 정렬을 구축
- 과반은 항상 정렬
- 하나씩 이동하거나, 한 번에 가장 큰 요소를 찾거나 한번에 가장 작은 요소를 찾는 대신
- 각 요소를 취하여 정렬되어 있는 절반 속 해당되는 위치에 배치
- [3,44,38,5,47,15] 이렇게 있을 때 44의 경우 3보다 크기 때문에 원래 자리에 위치
- 38의 경우 44와 비교 했을때 44보다 작고, 3과 비교했을때 3보다 크기 때문에, 3과 44 사이에서 44보다 작기 때문에 [3,38,44,5,47,15]로 위치 변경
- 다음 5의 경우 [3,38,44,5] 이렇게만 봤을때 3과 38 사이에 들어가야 하기때문에 [3,5,38,44,47,15]로 변경
- 47의 경우 [3,5,38,44,47] 중에서 제 위치이기 때문에 가만히
- 마지막 15의 경우  [3,5,15,38,44,47]로 위치
- 첫 번째 요소는 정렬되어 있다고 가정하고, 두 번째 요소부터 올바른 위치에 삽입.

<br/>
<br/>

# 🐣   삽입 정렬 구현<span id="2">

insertion_sort.js
```
function insertionSort(arr){
	var currentVal;
    for(var i = 1; i < arr.length; i++){
        currentVal = arr[i];
        for(var j = i - 1; j >= 0 && arr[j] > currentVal; j--) {
            arr[j+1] = arr[j]
        }
        arr[j+1] = currentVal;
    }
    return arr;
}

insertionSort([2,1,9,76,4])
```
- i = 1로 해두는 이유는 추가로 반복하지 않기 위해서임. 0으로 해도 상관은 없지만 무의미한 반복.
- 처음부터 시작하는 것보다 배열의 끝이나 중간에서 진행하는게 더 쉽기 때문에 거꾸로 루프(실제로 거꾸로 수행해야 할 작업이 없기 때문에 쉬움)
- 만약 [1,2,9,76,0] 배열로 돌린다하면
- 1,2,9,76은 그대로고 0의 경우 재배열 필요
- i가 4 값일 경우 0값에 해당하는거고
- 이를 j = i-1값이랑 계속해서 비교 즉, 3,2,1,0번째랑 비교
- for반복 조건안에 arr[j]가 현재값보다 클때라고 해놨기 때문에 그럴 경우 arr[j+1]값에 j를 넣음
- [1,2,9,76,0] 일때 0과 76을 비교해서 76이 더 크기 때문에 arr[5]값에 arr[4]값을 넣음
- [1,2,9,76,76] 이렇게 됨. 0은 이미 currentVal에 저장했기 때문에 걱정 안해도 됨.
- 이렇게 계속해서 반복 후에 제 위치인 [0,1,2,9,76]로 가게 됨

<br/>
<br/>

# 🐣   삽입 정렬 : 빅오 복잡도<span id="3">

- 가장 안 좋은 경우 O(n^2) 배열의 길이가 늘어날 수록 비교 횟수를 기본적으로 n제곱
- 삽입 정렬이 유리한 경우는 
- 예를들어 온라인 알고리즘이라는 데이터가 있어서 데이터가 들어오는 대로 작동하는 알고리즘. 
- 새로운 데이터를 수신하기 때문에 전체 배열을 한 번에 정렬할 필요가 없음.
- 예를들어 온라인에서 실시간으로 번호 제출하는 코드 받아서 정렬하려고 할 때, 삽입 정렬은 한 부분을 정렬된 배열로 유지하고 한 번에 항목을 삽입하여 작동하기 때문에 
- 어떤 숫자가 입력되더라도 필요한 위치에 놓을 수 있음
- 라이브, 스트리밍 방식으로 들어온 데이터 즉시 입력하는 상황에 편리
