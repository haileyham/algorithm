#<a href="#1">🐣 재귀 함수를 사용하는 이유 </a> <br/>
#<a href="#2">🐣 스택 호출하기</a> <br/>

<br/>
<br/>

# 🐣 재귀 함수를 사용하는 이유 <span id="1">
## 정의
재귀는 자기자신을 호출하는 절차. 자바스크립트(JavaScript)나 코드를 가지고 하는 모든 일.
우리가 말하는 재귀는 자기자신을 호출하는 함수. 스스로를 호출.
Laugh라는 이름의 함수가 존재하면 내부 함수의 이름도 Laugh.

## 살펴보기 (재귀 예시)
두 가지의 서로 다른 메소드에 걸쳐 실행되기는 하지만, 결국에는 이 사이클에서 두 함수가 서로를 호출.
즉, readValue가 readObject를 호출하고, readObject는 readValue를 호출하고, readValue는 다시 readObject를 호출.
이 사이클이 계속해서 반복. 

- JSON.parse와 JSON.stringify
- document.getElementByld와 DOM(Document Object Model) 
- 순회 알고리즘(traversal algorithm)
- DOM은 모든 요소가 중첩된 트리 구조. 그래서 div 안의 div에 div가 들어 있는 중첩 계층이 100개나 될 수도 있음. 만약에 그 모든 걸 살펴보고자 한다면, 흔한 접근법 중 하나는 재귀적으로 작동하는 코드를 작성.

# 🐣 스택 호출하기 <span id="2">

## 개념
거의 모든 프로그래밍 언어에는 함수 호출을 관리하는 데이터 구조가 있다. 호출된 함수는 종종 다른 함수가 반환될 때까지 기다린다. 특별한 순서가 있다. 그렇다. 함수들은 무작위로 실행되지 않는다. 먼저 호출되는 함수가 있고, 그 함수 내에서 두 번째 함수가 호출된다. 함수들은 올바른 순서대로 실행되어야 한다. 그래서 이를 처리하는 데이터 구조가 있다. JavaScript의 경우, 그것은 바로 호출 스택이다.

호출 스택을 종이 더미로 생각할 수 있다. 사실, 그것은 스택이라는 데이터 구조이다. 나중에 스택에 대해 배우게 될 것이다. 스택과 큐에 대해 들어본 적이 있을지도 모르겠지만, 지금 설명하려는 것은: 함수를 호출할 때, 그 함수는 호출 스택의 맨 위에 쌓인다. 마치 책상 위에 종이 더미를 쌓는 것처럼, 새로 추가된 함수는 맨 위에 위치한다. JavaScript는 return 키워드를 찾거나 함수 내에서 더 이상 실행할 코드가 없을 때, 컴파일러가 스택의 맨 위 항목을 제거한다.

그래서 스택의 개념을 설명할 때, 그것을 책상 위의 종이 더미에 비유한다. 무언가를 위에 놓기 때문이다. 심지어 무언가를 꺼낼 때도, 위에서부터 꺼낸다. 더미의 맨 아래에서 종이를 꺼내지 않는다. 무엇이든지 맨 위에 있는 것을 꺼낸다. 이것이 바로 호출 스택의 개념이다.

- 개발자도구 sources  > 버튼 or command + enter 실행으로 콜스택 확인 (next step 눌러보면서 순서 확인)
- 재귀 함수에서 호출 스택 많이 사용
- 보통의 경우 함수 완료 > 호출 스택 아래 > 제거
- 재귀의 경우 계속해서 새로운 함수 호출 스택에 추가(동일 함수 계속 추가, 추가된 함수는 호출 기다림)
- 어느 지점에 호출 종료 필요(종료 지점 없으면 무한 루프빠짐)

호출 스택은 자바스크립트의 보이지 않는 곳에서 작동하는 정적 데이터 구조(static data structure). 그 의미는 항목이 꼭대기에 추가되고 마찬가지로 꼭대기에서부터 제거되며, 함수가 호출되면 이 구조에 추가된다는 것.

## 첫번째 재귀함수

### 기본 요소
1. 라인을 끝내는 종료 조건 : 종료 지점이 있어야만 무한루프에 빠지지 않음

2. 다른 입력 값 : 계속해서 같은 값을 호출하는 것이 아니라 매번 다른 데이터로 함수 호출

### 코드로 살펴보기 
countdown.js
```
// Recursive Version
function countDown(num) {
  if (num <= 0) {
    console.log("All done!");
    return;
  }
  console.log(num);
  num--;
  countDown(num);
}
countDown(3)

// Iterative Version 재귀 사용하지 않고 반복문 사용
function countDown(num) {
  for (var i = num; i > 0; i--) {
    console.log(i);
  }
  console.log("All done!")
}

```

### 퀴즈
1. 자바스크립트는 함수 호출하기 위해 어떤 도구 사용?
- 스택 호출
2. 기본 케이스는 무엇?
- 재귀가 끝난 상태

------
<br/>
<br/>


## 두 번째 재귀함수

### 코드로 살펴보기
sumrange.js
```
function sumRange(num) {
  if (num === 1) return 1;
  return num + sumRange(num - 1);
}

sumRange(4)
```
위의 과정의 경우 다음과 같이 진행 됨
```
sumRange(3)
  return 3 + sumRange(2)
    return 2 + sumRange(1)
      return 1 
```
위의 순서로 진행이 되고 다시 살펴보면 거꾸로 진행됨
스택과정, 넣고 위에있는것부터 다시 계산하여 뺌
```
sumRange(3) // 아래에서 위로 순서대로 하여 6 나옴.
  return 3 + 3 // sumRange(2) 반환값 3 +3 = 6 ------ (3)
    return 2 + 1 // sumRange(1) 반환값 1 + 2 = 3  ------ (2)
      return 1 //함수 종료 1  ------ (1)
```


